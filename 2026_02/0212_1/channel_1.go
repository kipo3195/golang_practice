package main

import (
	"log"
	"sync"
)

// 20260212
// 채널을 만들고, 그 채널이 deadlock을 유발하는 코드, 채널 닫기를 통해 deadlock 해소
func main() {

	var wg sync.WaitGroup
	c := make(chan int)

	wg.Add(1) // "이제부터 추적할 작업이 1개 있어"라고 카운터를 올립니다.   ---------- 1
	go print(&wg, c)
	for i := 0; i < 10; i++ {
		c <- i
	}
	log.Println("여기가 실행되려나?") // -------------------- 3 실행됨
	// close(c)                               // 채널을 닫아버림
	wg.Wait()                              // --------------------- 카운터가 0이 될때까지 현재 위치에서 코드 실행을 중단하고 기다림.
	log.Println("여기가 실행되려나? - 아마도 5초 뒤? ") // ------------------- 4 실행되지 않음,  close(c) 채널을 닫아버리면 실행됨
}

func print(wg *sync.WaitGroup, c chan int) {
	// 무한 루프.. 채널에 들어오는 데이터를 계속 출력하려고함. --------- 2
	// 무한 루프에서 빼내도록 조건을 주거나, 아니면 채널을 닫아버리면 됨.
	for i := range c {
		log.Println(i)
	}
	// 로깅
	// 2026/02/12 16:20:46 0
	// 2026/02/12 16:20:46 1
	// 2026/02/12 16:20:46 2
	// 2026/02/12 16:20:46 3
	// 2026/02/12 16:20:46 4
	// 2026/02/12 16:20:46 5
	// 2026/02/12 16:20:46 6
	// 2026/02/12 16:20:46 7
	// 2026/02/12 16:20:46 8
	// 2026/02/12 16:20:46 9
	// fatal error: all goroutines are asleep - deadlock!
	wg.Done()
	// wg.Done()은 작업 하나 끝났다 라는 알림. Add로 올린 카운드 1 줄임.
	// 다만 위에서 for 무한 루프가 돌고 있으므로 wg.Done()이 실행 될 수 없음
}
